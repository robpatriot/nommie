# Nommie — Cursor Rules (v1.2.4)

> Keep this file at repo root. It applies to **all** AI actions (generate, edit, refactor, move/rename). If you must deviate, leave a short code comment explaining why.

## Purpose
- Apply these rules to all AI-assisted edits, refactors, and codegen.
- Prefer clarity and **small, reviewable diffs**. Explain non-obvious changes in **code comments** adjacent to the change.

## Tech Stack Hints
- Backend: Rust, Actix Web, SeaORM, PostgreSQL.
- Frontend: Next.js (App Router), TypeScript, Tailwind.
- Monorepo layout: /apps/frontend, /apps/backend, /packages, /docs.

## Global Conventions
- Domain logic stays **pure**: no DB access and no web framework imports in domain modules.
- Use **enums** over strings for states/roles/phases (code + schema).
- Prefer explicit, narrow interfaces and small functions over god objects.
- Respect linters/formatters: Rustfmt + Clippy, ESLint + Prettier.
- Tests must be **deterministic**; avoid time/RNG leaks unless seeded/injected.

### String Interpolation (JS/TS & Shell) — **Important**
- **Always interpolate variables inside the string using template literals: `${VAR}`.**
  - ✅ `console.log(\`Database name is ${DB_NAME}\`)`
  - ✅ `const url = \`${host}:${port}/${db}\``
  - ❌ `console.log("Database name is", DB_NAME)`
  - ❌ `"name: " + name`
- Prefer a **single formatted string** over passing variables as separate parameters to logging/print APIs.
- (Rust note): Use standard formatting macros (`format!`, `println!`, `tracing::*`) with `{}` placeholders; avoid string concatenation.

## Error Handling & Responses
- Handlers return `Result<T, AppError>` — **never** raw `HttpResponse`.
- Problem Details shape: `{ type, title, status, detail, code, trace_id }`.
- `code` is **SCREAMING_SNAKE_CASE** from a central registry (no ad-hoc strings).
- Ensure per-request `trace_id` flows into logs and responses.

## AppState & Configuration
- `AppState` holds DB pool and `SecurityConfig`; inject via `web::Data<AppState>`.
- **Do not** clone/rebuild security config ad-hoc; use shared state.

## Extractors
- **Available now (completed):** `AuthToken`, `JwtClaims`, `CurrentUser`, `CurrentUserDb`.
- **Planned (do NOT synthesize yet):**
  - `ValidatedJson<T>` → body validation wrapper returning Problem Details on failure.
  - `GameId` → autoincrement **bigint PK**, must verify existence and return 404 if missing.
  - `GameMembership` → resolve user + membership with a **single DB hit**.
- Authentication policy: Google OAuth for accounts; JWT for FE/BE auth; `users.sub` (JWT subject) is the stable identity (not numeric id).

## Schema Conventions
- **Single source of truth:** canonical schema lives in one idempotent `init.sql`.  
  - Do not create additional migration files unless policy changes.
- **Primary keys:** all tables use `BIGINT GENERATED BY DEFAULT AS IDENTITY` (autoincrement).  
  - No UUIDs or composite PKs unless explicitly requested.  
  - All cross-table references use bigint foreign keys.
- **Enums:** represent persistent states/roles/phases; no string literals in schema.  
- **Timestamps:** always stored in UTC.  
- **Indexes:** add indexes for FKs and for frequently queried fields (e.g. ordering by created_at).  
- **Test DB guard:** all destructive ops (drop/reset) are allowed only against `_test` databases.  
  - Never run destructive ops against non-`_test` DBs.  
- **Entities:** keep all models/entities in the initial migration until policy changes.

## Persistence Patterns (SeaORM)
- Prefer explicit column selection over `select(*)`.
- On updates/deletes check `rows_affected`; treat `0` as meaningful.
- No `unwrap()`/`expect()` outside tests; use `?` and map to `AppError`.
- Use **explicit transactions** for multi-row or multi-table flows; avoid partial writes.

## Transactions & Concurrency
- Use `DatabaseTransaction` for atomic sequences (e.g., play card → update trick → score).
- Keep transactions short; avoid long-lived locks.
- For turn-taking and “only-one-writes,” use row-level locking or safe uniqueness constraints; never rely on in-memory cross-request invariants.

## Domain Modules
- `rules`, `bidding`, `tricks`, `scoring`, `state` contain no DB/framework code.
- Orchestration/adapters sit above domain modules; no SeaORM in domain code.
- Provide helpers so domain logic is unit-testable without a DB.

## Time, Randomness & Determinism
- **No** `SystemTime::now()` in domain code. Inject a `Clock` trait; use a fixed `TestClock` in tests.
- RNG is passed in via interface; tests **must** seed RNG for reproducibility.

## Testing Policy
- Unit tests for new code; integration tests for complex flows.
- Provide assertion helpers for Problem Details and `trace_id`.
- Prefer **property tests** for trick/scoring invariants where practical.
- Tests are isolated and reset DB state; no test-order coupling.

### Testing Commands (important)
- **Backend tests:** `pnpm be:test` (loads env vars; u
