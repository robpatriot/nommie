version: 1
match: ["apps/backend/**"]
rules:
  - id: persistence-transactions
    text: |
      Repos and services are stateless and accept connections as parameters.
      Only SeaORM adapters depend on SeaORM; services depend only on repo traits.
      Connection type requirements:
      - Single reads: use `ConnectionTrait`.
      - Multiple unrelated reads: use `ConnectionTrait`.
      - Multiple related reads (need consistent snapshot): use `DatabaseTransaction`.
      - Any mutation: use `DatabaseTransaction`.
      Related data = queries with invariants between them (game + its round + that round's bids; round + its tricks + those tricks' plays).
      All DB work runs through `with_txn` or `require_db`.
      `with_txn` closures return `Result<_, AppError>`.
      Nested transactions only via `SharedTxn` in tests.
      Production: commit on `Ok`, rollback on `Err`. Tests: always rollback.
      Never call `begin`, `commit`, or `rollback` directly.
  - id: backend-code
    text: |
      Handlers return `Result<T, AppError>` — never `HttpResponse`.
      All DB access via `require_db(&state)` or `with_txn(&state, …)`.
      Only SeaORM adapters may `use sea_orm::*`.
      Domain modules: no DB or Actix imports.
      Use enums (not strings) for states, roles, and phases.
      No `unwrap()` or `expect()` outside tests.
      Always use inline format strings: `format!("value: {variable}")` never `format!("value: {}", variable)`.
  - id: strings
    text: |
      Query/lookup methods: accept `&str`.
      Mutating operations: take owned `String` (use `Option<String>` when optional).
      DTO constructors: use `impl Into<String>`.
  - id: extractors
    text: |
      Allowed: `AuthToken`, `JwtClaims`, `CurrentUser`, `GameId`, `GameMembership`, `CachedGameContext`, `ValidatedJson<T>`.
      `ValidatedJson<T>` maps validation errors to `AppError` Problem Details.
  - id: json-extractors
    text: |
      Always use `ValidatedJson<T>` for request body extraction in handlers, never `web::Json<T>`.
      `ValidatedJson` provides standardized RFC7807 error handling for JSON parse/validation failures.
      Example: `async fn handler(body: ValidatedJson<CreateRequest>) -> Result<web::Json<Response>, AppError>`
  - id: errors
    text: |
      Errors follow Problem Details: { type, title, status, detail, code, trace_id }.
      Create errors via `AppError` helpers.
      `code` comes from registry (no ad-hoc strings).
      Never leak raw serde/SQL/OAuth errors.
  - id: caching-etags
    text: |
      Mutable endpoints (`PATCH`, `DELETE`): enforce `If-Match`/`ETag`.
      Safe endpoints (`GET`, `HEAD`): support `If-None-Match`, return `304` when applicable.
      `ETag` must uniquely identify resource state.
      Never issue weak ETags or combine with `Last-Modified`.
  - id: logging
    text: |
      Logs must include `trace_id`.
      Mask or hash PII (emails, google_sub).
  - id: appstate
    text: |
      `AppState.db` is private — access via `state.db()` / `require_db(&state)`.
  - id: schema-migrations
    text: |
      We have NOT gone to production yet — freely modify the schema as needed.
      Schema lives in the single initial migration file under `apps/backend/migration`.
      Always update the initial migration file directly — do NOT create sequential migrations.
  - id: testing
    text: |
      Tests must be deterministic (seed time/RNG).
      DB tests use `_test` DB (rollback enforced).
      `SharedTxn` for tests needing continuity.
      Committed data tests use pooled DB setup.
      Error assertions: use structured checks (error codes, variants), not string matching.


