# Nommie — Cursor Rules (Workspace)

Repo-root workspace rules. Applies to all Cursor prompts, edits, refactors, and codegen.

## General
- Follow these rules exactly. If a request would break them, stop and ask.
- No commentary in edits — implement directly.
- Never run any git commands other than diff
- No deprecated or legacy code: Never use `#[deprecated]` or leave legacy/compatibility functions. Refactor callers instead.

## Persistence & Transactions

### Repository and Service Design
- Repos and services are stateless and accept connections as parameters.
- Only SeaORM adapters depend on SeaORM; services depend only on repo traits.

### Connection Type Requirements
- Single reads: use `ConnectionTrait`
- Multiple unrelated reads: use `ConnectionTrait`
- Multiple related reads (need consistent snapshot): use `DatabaseTransaction`
- Any mutation: use `DatabaseTransaction`

Related data = queries with invariants between them (game + its round + that round's bids; round + its tricks + those tricks' plays).

### Transaction Execution
- All DB work runs through `with_txn` or `require_db`.
- `with_txn` closures return `Result<_, AppError>`.
- Nested transactions only via `SharedTxn` in tests.
- Production: commit on `Ok`, rollback on `Err`.
- Tests: always rollback.
- Never call `begin`, `commit`, or `rollback` directly.

## Backend Code
- Handlers return `Result<T, AppError>` — never `HttpResponse`.
- All DB access via `require_db(&state)` or `with_txn(&state, …)`.
- Only SeaORM adapters may `use sea_orm::*`.
- Domain modules: no DB or Actix imports.
- Use enums (not strings) for states, roles, and phases.
- No `unwrap()` or `expect()` outside tests.
- Always use inline format strings: `format!("value: {variable}")` never `format!("value: {}", variable)`.

## String Handling
- Query/lookup methods: accept `&str`.
- Mutating operations: take owned `String` (use `Option<String>` when optional).
- DTO constructors: use `impl Into<String>`.

## Extractors
- Allowed: `AuthToken`, `JwtClaims`, `CurrentUser`, `GameId`, `GameMembership`, `CachedGameContext`, `ValidatedJson<T>`.
- `ValidatedJson<T>` maps validation errors to `AppError` Problem Details.

## Error Handling
- Errors follow Problem Details: `{ type, title, status, detail, code, trace_id }`.
- Create errors via `AppError` helpers.
- `code` comes from registry (no ad-hoc strings).
- Never leak raw serde/SQL/OAuth errors.

## ETags & Caching
- Mutable endpoints (`PATCH`, `DELETE`): enforce `If-Match`/`ETag`.
- Safe endpoints (`GET`, `HEAD`): support `If-None-Match`, return `304` when applicable.
- `ETag` must uniquely identify resource state.
- Never issue weak ETags or combine with `Last-Modified`.

## Logging
- Logs must include `trace_id`.
- Mask or hash PII (emails, google_sub).

## AppState
- `AppState.db` is private — access via `state.db()` / `require_db(&state)`.

## Schema & Migrations
- Schema lives in single init migration under `apps/backend/migration`.
- Don't add separate migration files, SQL, or DDL elsewhere.

## Env & pnpm
- Source `.env` once per shell session: `set -a; source .env; set +a`
- Don't read `DATABASE_URL` directly in code.

## Testing
- Tests must be deterministic (seed time/RNG).
- DB tests use `_test` DB (rollback enforced).
- `SharedTxn` for tests needing continuity.
- Committed data tests use pooled DB setup.
- Error assertions: use structured checks (error codes, variants), not string matching.
