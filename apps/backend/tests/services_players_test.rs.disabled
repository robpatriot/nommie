mod common;
mod support;

use async_trait::async_trait;

use backend::errors::domain::DomainError;
use backend::error::AppError;
use backend::repos::players::PlayerRepo;
use backend::services::players::PlayerService;
use backend::db::DbConn;
use serial_test::serial;

/// Mock database connection for testing
struct MockDbConn;

impl DbConn for MockDbConn {}

/// Mock implementation of PlayerRepo for testing
struct MockPlayerRepo {
    should_return_error: bool,
    error_type: Option<DomainError>,
    display_name: Option<String>,
}

impl MockPlayerRepo {
    fn new() -> Self {
        Self {
            should_return_error: false,
            error_type: None,
            display_name: Some("TestPlayer".to_string()),
        }
    }

    fn with_error(error: DomainError) -> Self {
        Self {
            should_return_error: true,
            error_type: Some(error),
            display_name: None,
        }
    }

    fn with_display_name(name: String) -> Self {
        Self {
            should_return_error: false,
            error_type: None,
            display_name: Some(name),
        }
    }
}

#[async_trait]
impl PlayerRepo for MockPlayerRepo {
    async fn get_display_name_by_seat(
        &self,
        _conn: &dyn backend::db::DbConn,
        _game_id: i64,
        _seat: u8,
    ) -> Result<String, DomainError> {
        if self.should_return_error {
            Err(self.error_type.clone().unwrap())
        } else {
            Ok(self.display_name.clone().unwrap())
        }
    }
}

#[tokio::test]
#[serial]
#[ignore] // TODO: Fix to work with new architecture - requires trait object approach
async fn test_get_display_name_by_seat_success() -> Result<(), AppError> {
    let repo = MockPlayerRepo::with_display_name("Alice".to_string());
    let service = PlayerService::new(std::sync::Arc::new(repo));

    // No database connection needed for service unit tests

    // Create a mock connection for testing - we'll use a simple approach
    // Since this is a unit test, we don't need a real DB connection
    // The mock repo will handle the logic
    let result = service.get_display_name_by_seat(&MockDbConn, 1, 0).await?;
    assert_eq!(result, "Alice");
    Ok(())
}

#[tokio::test]
#[serial]
#[ignore] // TODO: Fix to work with new architecture - requires trait object approach
async fn test_get_display_name_by_seat_invalid_seat() -> Result<(), AppError> {
    let repo = MockPlayerRepo::new();
    let service = PlayerService::new(std::sync::Arc::new(repo));

    // No database connection needed for service unit tests

    let result = service.get_display_name_by_seat(&MockDbConn, 1, 5).await;
    
    match result {
        Err(AppError::Validation { code, detail, .. }) => {
            assert_eq!(code, backend::errors::ErrorCode::InvalidSeat);
            assert!(detail.contains("Seat must be between 0 and 3"));
        }
        _ => panic!("Expected Validation error for invalid seat"),
    }

    Ok(())
}

#[tokio::test]
#[serial]
#[ignore] // TODO: Fix to work with new architecture - requires trait object approach
async fn test_get_display_name_by_seat_player_not_found() -> Result<(), AppError> {
    let repo = MockPlayerRepo::with_error(DomainError::not_found(
        backend::errors::domain::NotFoundKind::Other("Player".to_string()),
        "Player not found"
    ));
    let service = PlayerService::new(std::sync::Arc::new(repo));

    // No database connection needed for service unit tests

    let result = service.get_display_name_by_seat(&MockDbConn, 1, 0).await;
    
    match result {
        Err(AppError::NotFound { code, detail, .. }) => {
            assert_eq!(code, backend::errors::ErrorCode::PlayerNotFound);
            assert!(detail.contains("Player not found"));
        }
        Err(e) => {
            panic!("Expected NotFound error but got: {:?}", e);
        }
        Ok(display_name) => {
            panic!("Expected error but got success: {}", display_name);
        }
    }

    Ok(())
}

#[tokio::test]
#[serial]
#[ignore] // TODO: Fix to work with new architecture - requires trait object approach
async fn test_get_display_name_by_seat_invalid_seat_from_repo() -> Result<(), AppError> {
    let repo = MockPlayerRepo::with_error(DomainError::validation("Invalid seat"));
    let service = PlayerService::new(std::sync::Arc::new(repo));

    // No database connection needed for service unit tests

    let result = service.get_display_name_by_seat(&MockDbConn, 1, 0).await;
    
    match result {
        Err(AppError::Validation { code, detail, .. }) => {
            assert_eq!(code, backend::errors::ErrorCode::ValidationError);
            assert!(detail.contains("Invalid seat"));
        }
        Err(e) => {
            panic!("Expected Validation error but got: {:?}", e);
        }
        Ok(display_name) => {
            panic!("Expected error but got success: {}", display_name);
        }
    }

    Ok(())
}

#[tokio::test]
#[serial]
#[ignore] // TODO: Fix to work with new architecture - requires trait object approach
async fn test_get_display_name_by_seat_database_error() -> Result<(), AppError> {
    let repo = MockPlayerRepo::with_error(DomainError::infra(
        backend::errors::domain::InfraErrorKind::Other("Database error".to_string()),
        "Database connection failed"
    ));
    let service = PlayerService::new(std::sync::Arc::new(repo));

    // No database connection needed for service unit tests

    let result = service.get_display_name_by_seat(&MockDbConn, 1, 0).await;
    
    match result {
        Err(AppError::Internal { code, detail, .. }) => {
            assert_eq!(code, backend::errors::ErrorCode::InternalError);
            assert!(detail.contains("Database connection failed"));
        }
        _ => panic!("Expected Internal error for database error"),
    }

    Ok(())
}
